<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VRChat Bone Viewer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #060d14; overflow: hidden; }
    input[type=range] { accent-color: #00e5ff; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.2/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    const BONE_CONNECTIONS = [
      ["Hips","Spine"],["Spine","Chest"],["Chest","Neck"],["Neck","Head"],
      ["Chest","LeftShoulder"],["LeftShoulder","LeftUpperArm"],
      ["LeftUpperArm","LeftLowerArm"],["LeftLowerArm","LeftHand"],
      ["Chest","RightShoulder"],["RightShoulder","RightUpperArm"],
      ["RightUpperArm","RightLowerArm"],["RightLowerArm","RightHand"],
      ["Hips","LeftUpperLeg"],["LeftUpperLeg","LeftLowerLeg"],
      ["LeftLowerLeg","LeftFoot"],["LeftFoot","LeftToes"],
      ["Hips","RightUpperLeg"],["RightUpperLeg","RightLowerLeg"],
      ["RightLowerLeg","RightFoot"],["RightFoot","RightToes"],
    ];

    function getBoneColor(name) {
      if (name.startsWith("Left"))  return 0xff6b6b;
      if (name.startsWith("Right")) return 0x69ff96;
      if (name === "Hips")          return 0xffe066;
      return 0x00e5ff;
    }

    function parseCSV(text) {
      const lines = text.trim().split(/\r?\n/);
      const headers = lines[0].split(",");
      const data = [];
      for (let i = 1; i < lines.length; i++) {
        const vals = lines[i].split(",");
        if (vals.length < headers.length) continue;
        const row = {};
        headers.forEach((h, j) => { row[h.trim()] = vals[j]?.trim(); });
        data.push(row);
      }
      return data;
    }

    function buildFrames(rows) {
      const frameMap = new Map();
      for (const row of rows) {
        const f = parseInt(row.frame);
        if (!frameMap.has(f)) {
          frameMap.set(f, { frame: f, time: parseFloat(row.unity_time), bones: {} });
        }
        frameMap.get(f).bones[row.bone] = {
          x: parseFloat(row.pos_x),
          y: parseFloat(row.pos_y),
          z: parseFloat(row.pos_z),
        };
      }
      return Array.from(frameMap.values()).sort((a, b) => a.frame - b.frame);
    }

    function BoneViewer() {
      const mountRef  = useRef(null);
      const sceneRef  = useRef(null);
      const rendRef   = useRef(null);
      const cameraRef = useRef(null);
      const frameObjs = useRef({ joints: {}, bones: {} });
      const gridRef   = useRef(null);
      const lastMouse = useRef({ x: 0, y: 0 });
      const spherical = useRef({ theta: 0.4, phi: 1.2, radius: 3 });
      const lookTarget= useRef(new THREE.Vector3(0, 1, 0));
      const animRef   = useRef(null);
      const playRef   = useRef(false);
      const dragMode  = useRef(null);
      const playStartWall     = useRef(null);
      const playStartDataTime = useRef(null);
      const playModeRef       = useRef("fps");
      const playSpeedRef      = useRef(1);
      const followModeRef     = useRef(true);

      const [frames, setFrames]         = useState([]);
      const [current, setCurrent]       = useState(0);
      const [playing, setPlaying]       = useState(false);
      const [fps, setFps]               = useState(30);
      const [playMode, setPlayMode]     = useState("fps");
      const [playSpeed, setPlaySpeed]   = useState(1);
      const [loaded, setLoaded]         = useState(false);
      const [fileName, setFileName]     = useState("");
      const [followMode, setFollowMode] = useState(true);

      useEffect(() => { followModeRef.current = followMode; }, [followMode]);
      useEffect(() => { playModeRef.current   = playMode;   }, [playMode]);
      useEffect(() => { playSpeedRef.current  = playSpeed;  }, [playSpeed]);
      useEffect(() => { playRef.current       = playing;    }, [playing]);

      // Three.js 初期化
      useEffect(() => {
        const W = mountRef.current.clientWidth;
        const H = mountRef.current.clientHeight;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(W, H);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000, 0);
        mountRef.current.appendChild(renderer.domElement);
        rendRef.current = renderer;

        const scene = new THREE.Scene();
        sceneRef.current = scene;

        const grid = new THREE.GridHelper(10, 20, 0x1a2a3a, 0x0d1a24);
        grid.position.y = -0.05;
        scene.add(grid);
        gridRef.current = grid;

        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const dir = new THREE.DirectionalLight(0x88ccff, 1.2);
        dir.position.set(3, 5, 3);
        scene.add(dir);

        const camera = new THREE.PerspectiveCamera(50, W / H, 0.01, 100);
        camera.position.set(0, 1.2, 3);
        camera.lookAt(0, 1, 0);
        cameraRef.current = camera;

        const animate = () => {
          animRef.current = requestAnimationFrame(animate);
          renderer.render(scene, camera);
        };
        animate();

        const onResize = () => {
          const w = mountRef.current?.clientWidth || W;
          const h = mountRef.current?.clientHeight || H;
          renderer.setSize(w, h);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        };
        window.addEventListener("resize", onResize);

        return () => {
          cancelAnimationFrame(animRef.current);
          window.removeEventListener("resize", onResize);
          renderer.dispose();
          mountRef.current?.removeChild(renderer.domElement);
        };
      }, []);

      // カメラ更新
      const updateCamera = useCallback(() => {
        const s = spherical.current;
        const t = lookTarget.current;
        const cam = cameraRef.current;
        if (!cam) return;
        cam.position.set(
          t.x + s.radius * Math.sin(s.phi) * Math.sin(s.theta),
          t.y + s.radius * Math.cos(s.phi),
          t.z + s.radius * Math.sin(s.phi) * Math.cos(s.theta)
        );
        cam.lookAt(t);
      }, []);

      // カメラ操作（Unity スタイル）
      const onMouseDown = (e) => {
        if (e.button === 2) { dragMode.current = "rotate"; e.preventDefault(); }
        if (e.button === 1) { dragMode.current = "pan";    e.preventDefault(); }
        lastMouse.current = { x: e.clientX, y: e.clientY };
      };
      const onMouseMove = useCallback((e) => {
        if (!dragMode.current) return;
        const dx = e.clientX - lastMouse.current.x;
        const dy = e.clientY - lastMouse.current.y;
        lastMouse.current = { x: e.clientX, y: e.clientY };
        if (dragMode.current === "rotate") {
          const s = spherical.current;
          s.theta -= dx * 0.005;
          s.phi = Math.max(0.1, Math.min(Math.PI - 0.1, s.phi - dy * 0.005));
          updateCamera();
        }
        if (dragMode.current === "pan") {
          const cam = cameraRef.current;
          if (!cam) return;
          const s = spherical.current;
          const right = new THREE.Vector3();
          const up    = new THREE.Vector3();
          right.setFromMatrixColumn(cam.matrix, 0);
          up.setFromMatrixColumn(cam.matrix, 1);
          const panSpeed = s.radius * 0.001;
          lookTarget.current.addScaledVector(right, -dx * panSpeed);
          lookTarget.current.addScaledVector(up,     dy * panSpeed);
          updateCamera();
        }
      }, [updateCamera]);
      const onMouseUp = (e) => {
        if (e.button === 2 || e.button === 1) dragMode.current = null;
      };
      const onWheel = (e) => {
        const s = spherical.current;
        s.radius = Math.max(0.5, Math.min(12, s.radius + e.deltaY * 0.005));
        updateCamera();
      };
      const onContextMenu = (e) => e.preventDefault();

      // スケルトン初期化
      const initSkeleton = useCallback(() => {
        const scene = sceneRef.current;
        if (!scene) return;
        Object.values(frameObjs.current.joints).forEach(o => scene.remove(o));
        Object.values(frameObjs.current.bones).forEach(o => scene.remove(o));
        frameObjs.current = { joints: {}, bones: {} };

        const allBones = new Set();
        BONE_CONNECTIONS.forEach(([a, b]) => { allBones.add(a); allBones.add(b); });

        allBones.forEach(name => {
          const geo = new THREE.SphereGeometry(0.018, 12, 12);
          const mat = new THREE.MeshStandardMaterial({
            color: getBoneColor(name), emissive: getBoneColor(name),
            emissiveIntensity: 0.5, roughness: 0.3, metalness: 0.7,
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.visible = false;
          scene.add(mesh);
          frameObjs.current.joints[name] = mesh;
        });

        BONE_CONNECTIONS.forEach(([a, b]) => {
          const key = `${a}-${b}`;
          const geo = new THREE.CylinderGeometry(0.006, 0.006, 1, 8);
          const mat = new THREE.MeshStandardMaterial({
            color: 0x334455, emissive: 0x112233, emissiveIntensity: 0.3,
            roughness: 0.6, metalness: 0.4, transparent: true, opacity: 0.85,
          });
          const mesh = new THREE.Mesh(geo, mat);
          mesh.visible = false;
          scene.add(mesh);
          frameObjs.current.bones[key] = mesh;
        });
      }, []);

      // フレーム描画
      const renderFrame = useCallback((frameData) => {
        if (!frameData) return;
        const bones = frameData.bones;
        const jo = frameObjs.current.joints;
        const bo = frameObjs.current.bones;

        const hip = bones["Hips"];
        if (hip && followModeRef.current) {
          lookTarget.current.set(hip.x, hip.y, hip.z);
          updateCamera();
        }

        Object.entries(jo).forEach(([name, mesh]) => {
          const b = bones[name];
          if (b && !(b.x === 0 && b.y === 0 && b.z === 0)) {
            mesh.position.set(b.x, b.y, b.z);
            mesh.visible = true;
          } else {
            mesh.visible = false;
          }
        });

        BONE_CONNECTIONS.forEach(([a, b]) => {
          const key = `${a}-${b}`;
          const ma = jo[a], mb = jo[b];
          const cyl = bo[key];
          if (!cyl || !ma?.visible || !mb?.visible) {
            if (cyl) cyl.visible = false;
            return;
          }
          const pa = ma.position, pb = mb.position;
          const mid = new THREE.Vector3().addVectors(pa, pb).multiplyScalar(0.5);
          const len = pa.distanceTo(pb);
          if (len < 0.001) { cyl.visible = false; return; }
          cyl.position.copy(mid);
          cyl.scale.set(1, len, 1);
          const dir = new THREE.Vector3().subVectors(pb, pa).normalize();
          cyl.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
          cyl.visible = true;
        });
      }, [updateCamera]);

      useEffect(() => {
        if (frames.length > 0 && frames[current]) renderFrame(frames[current]);
      }, [current, frames, renderFrame]);

      // ファイル読み込み
      const handleFile = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        setFileName(file.name);
        const reader = new FileReader();
        reader.onload = (ev) => {
          const rows = parseCSV(ev.target.result);
          const f = buildFrames(rows);
          setFrames(f);
          setCurrent(0);
          setLoaded(true);
          initSkeleton();

          const scene = sceneRef.current;
          if (scene && gridRef.current && f.length > 0) {
            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            let cx = 0, cz = 0, count = 0;
            for (const frame of f) {
              const hip = frame.bones["Hips"];
              if (!hip) continue;
              minX = Math.min(minX, hip.x); maxX = Math.max(maxX, hip.x);
              minZ = Math.min(minZ, hip.z); maxZ = Math.max(maxZ, hip.z);
              cx += hip.x; cz += hip.z; count++;
            }
            if (count > 0) {
              cx /= count; cz /= count;
              const rawSize = Math.max(maxX - minX, maxZ - minZ, 4) * 1.5;
              const gridSize = Math.ceil(rawSize / 0.5) * 0.5;
              const divisions = Math.round(gridSize / 0.5);
              scene.remove(gridRef.current);
              const newGrid = new THREE.GridHelper(gridSize, divisions, 0x1a2a3a, 0x0d1a24);
              newGrid.position.set(cx, -0.05, cz);
              scene.add(newGrid);
              gridRef.current = newGrid;
            }
          }
        };
        reader.readAsText(file, "utf-8");
      };

      // 再生開始時に基準時刻をセット
      useEffect(() => {
        if (playing && frames.length > 0) {
          playStartWall.current     = performance.now();
          playStartDataTime.current = frames[current]?.time ?? 0;
        }
      // eslint-disable-next-line react-hooks/exhaustive-deps
      }, [playing]);

      // FPS モード再生
      useEffect(() => {
        if (!playing || frames.length === 0 || playMode !== "fps") return;
        const interval = setInterval(() => {
          if (!playRef.current) return;
          setCurrent(c => {
            const next = c + 1;
            if (next >= frames.length) { setPlaying(false); return c; }
            return next;
          });
        }, 1000 / fps);
        return () => clearInterval(interval);
      }, [playing, frames.length, fps, playMode]);

      // リアルタイムモード再生
      useEffect(() => {
        if (!playing || frames.length === 0 || playMode !== "realtime") return;
        const times = frames.map(f => f.time);
        const tick = () => {
          if (!playRef.current) return;
          const elapsed = (performance.now() - playStartWall.current) / 1000 * playSpeedRef.current;
          const targetTime = playStartDataTime.current + elapsed;
          if (targetTime >= times[times.length - 1]) {
            setPlaying(false); setCurrent(frames.length - 1); return;
          }
          let lo = 0, hi = times.length - 1;
          while (lo < hi) {
            const mid = (lo + hi) >> 1;
            if (times[mid] < targetTime) lo = mid + 1; else hi = mid;
          }
          setCurrent(lo);
          rafId = requestAnimationFrame(tick);
        };
        let rafId = requestAnimationFrame(tick);
        return () => cancelAnimationFrame(rafId);
      }, [playing, frames, playMode]);

      const frameData = frames[current];

      return (
        <div style={{
          width:"100vw", height:"100vh", background:"#060d14",
          display:"flex", flexDirection:"column",
          fontFamily:"'Courier New', monospace", color:"#7ecfff", overflow:"hidden",
        }}>
          {/* ヘッダー */}
          <div style={{
            padding:"10px 20px", borderBottom:"1px solid #0d2535",
            display:"flex", alignItems:"center", gap:20,
            background:"rgba(0,20,35,0.9)", backdropFilter:"blur(8px)", zIndex:10,
          }}>
            <div style={{ fontSize:13, letterSpacing:3, color:"#00e5ff", fontWeight:"bold" }}>BONE VIEWER</div>
            <div style={{ fontSize:11, color:"#2a5a7a", letterSpacing:1 }}>VRChat Motion Capture</div>
            <div style={{ marginLeft:"auto", display:"flex", alignItems:"center", gap:12 }}>
              <label style={{
                padding:"5px 14px", border:"1px solid #00e5ff", color:"#00e5ff",
                fontSize:11, letterSpacing:2, cursor:"pointer", background:"rgba(0,229,255,0.05)",
              }}>
                CSV LOAD
                <input type="file" accept=".csv" onChange={handleFile} style={{ display:"none" }} />
              </label>
              {fileName && (
                <span style={{ fontSize:10, color:"#2a6a8a", maxWidth:200, overflow:"hidden", textOverflow:"ellipsis", whiteSpace:"nowrap" }}>
                  {fileName}
                </span>
              )}
            </div>
          </div>

          {/* メインエリア */}
          <div style={{ flex:1, display:"flex", position:"relative", overflow:"hidden" }}>
            <div
              ref={mountRef}
              style={{ flex:1, background:"linear-gradient(180deg,#060d14 0%,#0a1a2a 100%)", cursor:"default" }}
              onMouseDown={onMouseDown}
              onMouseMove={onMouseMove}
              onMouseUp={onMouseUp}
              onMouseLeave={onMouseUp}
              onWheel={onWheel}
              onContextMenu={onContextMenu}
            />

            {/* 情報パネル */}
            <div style={{
              position:"absolute", top:12, left:12, width:180,
              background:"rgba(6,13,20,0.85)", border:"1px solid #0d2535",
              backdropFilter:"blur(6px)", padding:"12px 14px",
              fontSize:10, lineHeight:2, letterSpacing:1,
            }}>
              <div style={{ color:"#00e5ff", marginBottom:6, fontSize:11, letterSpacing:3 }}>INFO</div>
              <div style={{ color:"#2a6a8a" }}>FRAMES <span style={{ color:"#7ecfff", float:"right" }}>{frames.length}</span></div>
              <div style={{ color:"#2a6a8a" }}>FRAME  <span style={{ color:"#7ecfff", float:"right" }}>{current}</span></div>
              <div style={{ color:"#2a6a8a" }}>TIME   <span style={{ color:"#7ecfff", float:"right" }}>{frameData ? frameData.time.toFixed(3) : "---"}s</span></div>
              <div style={{ color:"#2a6a8a" }}>BONES  <span style={{ color:"#7ecfff", float:"right" }}>22</span></div>
              {frameData?.bones?.Hips && (
                <>
                  <div style={{ marginTop:8, paddingTop:8, borderTop:"1px solid #0d2535", color:"#ffe066", fontSize:9, letterSpacing:2 }}>HIPS (world)</div>
                  <div style={{ color:"#2a6a8a", fontSize:9 }}>X <span style={{ color:"#ffe066", float:"right" }}>{frameData.bones.Hips.x.toFixed(3)}</span></div>
                  <div style={{ color:"#2a6a8a", fontSize:9 }}>Y <span style={{ color:"#ffe066", float:"right" }}>{frameData.bones.Hips.y.toFixed(3)}</span></div>
                  <div style={{ color:"#2a6a8a", fontSize:9 }}>Z <span style={{ color:"#ffe066", float:"right" }}>{frameData.bones.Hips.z.toFixed(3)}</span></div>
                </>
              )}
              <div style={{ marginTop:10, paddingTop:10, borderTop:"1px solid #0d2535", color:"#1a4060", fontSize:9 }}>
                RMB drag: rotate<br />MMB drag: pan<br />WHEEL: zoom<br />
                <span style={{ color: followMode ? "#ffe066" : "#2a6a8a" }}>
                  CAM: {followMode ? "FOLLOW" : "WORLD FIXED"}
                </span>
              </div>
            </div>

            {/* 凡例 */}
            <div style={{
              position:"absolute", top:12, right:12,
              background:"rgba(6,13,20,0.85)", border:"1px solid #0d2535",
              backdropFilter:"blur(6px)", padding:"12px 14px",
              fontSize:10, letterSpacing:1, lineHeight:2.2,
            }}>
              <div style={{ color:"#00e5ff", marginBottom:4, fontSize:11, letterSpacing:3 }}>LEGEND</div>
              {[["SPINE / HEAD","#00e5ff"],["LEFT","#ff6b6b"],["RIGHT","#69ff96"],["HIPS","#ffe066"]].map(([label, color]) => (
                <div key={label} style={{ display:"flex", alignItems:"center", gap:8, color:"#2a6a8a" }}>
                  <div style={{ width:8, height:8, borderRadius:"50%", background:color, boxShadow:`0 0 6px ${color}` }} />
                  {label}
                </div>
              ))}
            </div>

            {/* 未ロード表示 */}
            {!loaded && (
              <div style={{
                position:"absolute", inset:0, display:"flex", flexDirection:"column",
                alignItems:"center", justifyContent:"center", pointerEvents:"none",
              }}>
                <div style={{ fontSize:11, letterSpacing:4, color:"#0d2535", marginBottom:8 }}>NO DATA LOADED</div>
                <div style={{ fontSize:10, letterSpacing:2, color:"#0a1a28" }}>CSVファイルをロードしてください</div>
              </div>
            )}
          </div>

          {/* 下部コントロール */}
          <div style={{
            padding:"10px 20px", borderTop:"1px solid #0d2535",
            background:"rgba(0,10,18,0.95)", display:"flex", flexDirection:"column", gap:8,
          }}>
            <input
              type="range" min={0} max={Math.max(0, frames.length - 1)} value={current}
              onChange={e => { setPlaying(false); setCurrent(Number(e.target.value)); }}
              style={{ width:"100%", height:3, cursor:"pointer" }}
            />
            <div style={{ display:"flex", alignItems:"center", gap:16 }}>
              <button
                onClick={() => { if (loaded) setPlaying(p => !p); }}
                style={{
                  padding:"5px 20px",
                  border:`1px solid ${playing ? "#ff6b6b" : "#00e5ff"}`,
                  background: playing ? "rgba(255,107,107,0.08)" : "rgba(0,229,255,0.08)",
                  color: playing ? "#ff6b6b" : "#00e5ff",
                  fontSize:11, letterSpacing:3, cursor:"pointer",
                }}
              >{playing ? "■ STOP" : "▶ PLAY"}</button>

              <button
                onClick={() => { setPlaying(false); setCurrent(c => Math.max(0, c - 1)); }}
                style={{ padding:"5px 12px", border:"1px solid #0d2535", background:"transparent", color:"#2a6a8a", fontSize:12, cursor:"pointer" }}
              >◀</button>

              <button
                onClick={() => { setPlaying(false); setCurrent(c => Math.min(frames.length - 1, c + 1)); }}
                style={{ padding:"5px 12px", border:"1px solid #0d2535", background:"transparent", color:"#2a6a8a", fontSize:12, cursor:"pointer" }}
              >▶</button>

              <button
                onClick={() => { setPlaying(false); setCurrent(0); }}
                style={{ padding:"5px 10px", border:"1px solid #0d2535", background:"transparent", color:"#2a6a8a", fontSize:10, letterSpacing:1, cursor:"pointer" }}
              >RESET</button>

              <button
                onClick={() => setFollowMode(m => { const n = !m; followModeRef.current = n; return n; })}
                style={{
                  padding:"5px 14px",
                  border:`1px solid ${followMode ? "#ffe066" : "#2a6a8a"}`,
                  background: followMode ? "rgba(255,224,102,0.08)" : "transparent",
                  color: followMode ? "#ffe066" : "#2a6a8a",
                  fontSize:10, letterSpacing:2, cursor:"pointer",
                }}
              >{followMode ? "⊙ FOLLOW" : "⊙ WORLD"}</button>

              <div style={{ marginLeft:"auto", display:"flex", alignItems:"center", gap:8, fontSize:10, color:"#2a6a8a", letterSpacing:1 }}>
                {["fps","realtime"].map(m => (
                  <button key={m}
                    onClick={() => { setPlaying(false); setPlayMode(m); }}
                    style={{
                      padding:"3px 10px",
                      border:`1px solid ${playMode === m ? "#00e5ff" : "#0d2535"}`,
                      background: playMode === m ? "rgba(0,229,255,0.12)" : "transparent",
                      color: playMode === m ? "#00e5ff" : "#2a6a8a",
                      fontSize:10, cursor:"pointer", letterSpacing:1,
                    }}
                  >{m === "fps" ? "FPS" : "REALTIME"}</button>
                ))}

                <div style={{ width:1, height:14, background:"#0d2535", margin:"0 2px" }} />

                {playMode === "fps" && [15,30,60,90].map(f => (
                  <button key={f} onClick={() => setFps(f)}
                    style={{
                      padding:"3px 8px",
                      border:`1px solid ${fps === f ? "#00e5ff" : "#0d2535"}`,
                      background: fps === f ? "rgba(0,229,255,0.12)" : "transparent",
                      color: fps === f ? "#00e5ff" : "#2a6a8a",
                      fontSize:10, cursor:"pointer",
                    }}
                  >{f}</button>
                ))}

                {playMode === "realtime" && [0.25,0.5,1,2].map(sp => (
                  <button key={sp} onClick={() => setPlaySpeed(sp)}
                    style={{
                      padding:"3px 8px",
                      border:`1px solid ${playSpeed === sp ? "#69ff96" : "#0d2535"}`,
                      background: playSpeed === sp ? "rgba(105,255,150,0.10)" : "transparent",
                      color: playSpeed === sp ? "#69ff96" : "#2a6a8a",
                      fontSize:10, cursor:"pointer",
                    }}
                  >{sp}x</button>
                ))}
              </div>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<BoneViewer />);
  </script>
</body>
</html>
